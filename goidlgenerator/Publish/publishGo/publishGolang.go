package publishGo

import (
	"bufio"
	"fmt"
	"github.com/bhbosman/Application/goidlgenerator/Publish"
	"github.com/bhbosman/Application/goidlgenerator/interfaces"
	"github.com/bhbosman/Application/goidlgenerator/yacc"
	"io"
	"reflect"
)

func GetExportValue(value interfaces.IConstantValue) string {
	if value.ValueKind() == reflect.String {
		if value.MaxLength() == 1 {
			return fmt.Sprintf("'%v'", value.Value())
		}
		return fmt.Sprintf("\"%v\"", value.Value())
	}
	return fmt.Sprintf("%v", value.Value())
}

type publishGolang struct {
}

func (self *publishGolang) Export(outputStream io.Writer, packageName string, declaredTypes []interfaces.IDefinitionDeclaration) error {
	sb := bufio.NewWriter(outputStream)

	_, _ = sb.WriteString(fmt.Sprintf("// Code generated by goyacc -o idl.go -p IdlExpr idl.y. DO NOT EDIT.\n"))
	_, _ = sb.WriteString(fmt.Sprintf("package %v\n", packageName))
	_, _ = sb.WriteString(fmt.Sprintf("\n"))

	for _, declaredType := range declaredTypes {
		if definition, ok := declaredType.(*yacc.StructDefinition); ok {
			publish := NewPublishStruct(definition)
			publish.Export(sb)
			continue
		}

		if definition, ok := declaredType.(*yacc.EnumDecl); ok {
			publish := NewPublishEnum(definition)
			publish.Export(sb)
			continue
		}
		if typeDeclarator, ok := declaredType.(*yacc.TypeDeclarator); ok {
			publish := NewpublishTypeDecl(typeDeclarator)
			publish.Export(sb)
			continue
		}
	}
	_ = sb.Flush()
	return nil
}

func newPublishGolang() *publishGolang {
	return &publishGolang{}
}

func init() {
	Publish.Register(Publish.Go, newPublishGolang())
}
